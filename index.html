<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>need more chickens</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #ffffff;
            font-family: monospace;
            font-size: 14px;
        }

        .links-section {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 1px solid #ccc;
        }

        .links-section h2 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        .links-section ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .links-section li {
            margin: 5px 0;
        }

        .links-section a {
            color: #0000EE;
            text-decoration: underline;
        }

        .links-section a:visited {
            color: #551A8B;
        }

        .telegram-feed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 1px solid #ccc;
            max-height: 200px;
            max-width: 350px;
            overflow-y: auto;
        }

        .telegram-feed h2 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        .telegram-feed ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .telegram-feed li {
            margin: 8px 0;
            padding-bottom: 8px;
            border-bottom: 1px dotted #ccc;
        }

        .telegram-feed li:last-child {
            border-bottom: none;
        }

        .telegram-feed .post-time {
            color: #666;
            font-size: 12px;
        }

        .telegram-feed .post-content {
            margin-top: 4px;
        }

        .telegram-feed .post-images {
            margin-top: 6px;
        }

        .telegram-feed .post-images img {
            max-width: 100%;
            max-height: 150px;
            margin: 2px;
            border: 1px solid #ddd;
        }

        .telegram-feed a {
            color: #0000EE;
            text-decoration: underline;
        }

        .telegram-feed a:visited {
            color: #551A8B;
        }

        .chicken {
            position: absolute;
            width: 32px;
            height: 32px;
            background-image: url('./assets/chicken.PNG');
            background-repeat: no-repeat;
            image-rendering: pixelated;
            z-index: 999;
        }

        #feed-bag {
            position: fixed;
            top: 50%;
            right: 20px;
            width: 64px;
            height: 64px;
            background-image: url('./assets/feed-bag.PNG');
            background-size: contain;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            cursor: pointer;
            z-index: 1001;
            transform: translateY(-50%);
        }

        #feed-bag:hover {
            filter: brightness(1.2);
        }

        .feed {
            position: absolute;
            width: 16px;
            height: 16px;
            background-image: url('./assets/feed.PNG');
            background-repeat: no-repeat;
            background-position: 0px 0px;
            image-rendering: pixelated;
            z-index: 998;
        }

        .mouse-feed {
            position: fixed;
            width: 16px;
            height: 16px;
            background-image: url('./assets/feed.PNG');
            background-repeat: no-repeat;
            background-position: 0px 0px;
            image-rendering: pixelated;
            z-index: 1002;
            pointer-events: none;
            display: none;
        }

        .chick {
            position: absolute;
            width: 16px;
            height: 16px;
            background-image: url('./assets/chick.PNG');
            background-repeat: no-repeat;
            background-position: 0px 0px;
            image-rendering: pixelated;
            z-index: 999;
        }

        .egg {
            position: absolute;
            width: 16px;
            height: 16px;
            background-image: url('./assets/egg.PNG');
            background-repeat: no-repeat;
            background-position: 0px 0px;
            image-rendering: pixelated;
            z-index: 998;
        }

        .farm-building {
            position: absolute;
            border: 2px dashed #8B4513;
            background: rgba(139, 69, 19, 0.1);
            padding: 15px;
            box-sizing: border-box;
            font-family: monospace;
            z-index: 500;
            text-decoration: none;
            display: block;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .farm-building:hover {
            background: rgba(139, 69, 19, 0.2);
            border-color: #654321;
            transform: scale(1.05);
        }

        .farm-building h3 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #8B4513;
            font-weight: bold;
        }

        .farm-building p {
            margin: 0;
            font-size: 12px;
            color: #666;
            font-style: italic;
        }

        .farm-building.coming-soon {
            opacity: 0.6;
            cursor: default;
        }

        .farm-building.coming-soon:hover {
            transform: none;
            background: rgba(139, 69, 19, 0.1);
        }

        /* Individual building positions */
        #farmhouse {
            top: 50px;
            left: 50%;
            margin-left: -90px;
            width: 180px;
            height: 120px;
        }

        #chicken-coop {
            top: 250px;
            left: 280px;
            width: 150px;
            height: 100px;
        }

        #workshop {
            top: 200px;
            right: 100px;
            width: 160px;
            height: 100px;
        }

        #garden {
            bottom: 100px;
            left: 100px;
            width: 170px;
            height: 120px;
        }

        #farm-stand {
            bottom: 100px;
            right: 100px;
            width: 150px;
            height: 100px;
        }
    </style>
</head>
<body>
    <div class="links-section">
        <h2>mom's stuff</h2>
        <ul>
            <li><a href="https://t.me/mombotpro">mombot telegram feed</a></li>
            <li><a href="https://www.webtoons.com/en/canvas/liminal-b/list?title_no=443514">Liminal webtoon -complete-</a></li>
            <li><a href="https://mombot.nekoweb.org/mosaic">mosaic</a></li>
            <li><a href="https://mombotro.itch.io/">itch.io</a></li>
            <li><a href="https://ko-fi.com/azirona">ko-fi</a></li>
        </ul>
        <h2>cool links</h2>
        <ul>
            <li><a href="https://archive.org/details/babettes-feast">good movie</a></li>
            <li><a href="https://www.cherokeedictionary.net/grammar">Cherokee dictionary</a></li>
            <li><a href="https://drawingbooks.org/">open drawing books</a></li>
        </ul>
    </div>

    <div class="telegram-feed">
        <h2><a href="https://t.me/mombotpro" target="_blank">tg feed</a></h2>
        <ul id="telegram-posts">
            <li>Loading...</li>
        </ul>
    </div>

    <div id="feed-bag" title="Click to get chicken feed"></div>
    <div id="mouse-feed" class="mouse-feed"></div>

    <!-- Farm Buildings -->
    <div id="farmhouse" class="farm-building coming-soon">
        <h3>üè† FARMHOUSE</h3>
        <p>About/Contact</p>
        <p style="margin-top: 10px; font-size: 10px;">(coming soon)</p>
    </div>

    <a id="chicken-coop" class="farm-building" href="./gallery/comics/">
        <h3>üêî CHICKEN COOP</h3>
        <p>Comics/Webcomics</p>
    </a>

    <a id="workshop" class="farm-building" href="./gallery/tools/">
        <h3>üî® WORKSHOP</h3>
        <p>Little Programs & Tools</p>
    </a>

    <a id="garden" class="farm-building" href="./gallery/projects/">
        <h3>üå± GARDEN</h3>
        <p>3D Printing & Embroidery</p>
    </a>

    <div id="farm-stand" class="farm-building coming-soon">
        <h3>üõí FARM STAND</h3>
        <p>Stores & Links</p>
        <p style="margin-top: 10px; font-size: 10px;">(coming soon)</p>
    </div>

    <!-- Chickens will be created dynamically -->

    <script>
        // Load Telegram feed from JSON
        async function loadTelegramFeed() {
            const container = document.getElementById('telegram-posts');
            try {
                const response = await fetch('./posts.json');
                const posts = await response.json();

                if (posts.length === 0) {
                    container.innerHTML = '<li>No posts yet</li>';
                    return;
                }

                container.innerHTML = posts.map(post => {
                    let html = `<li>
                        <span class="post-time">${post.time || ''}</span>
                        <div class="post-content">${post.html || post.text || ''}</div>`;

                    if (post.images && post.images.length > 0) {
                        html += '<div class="post-images">';
                        post.images.forEach(img => {
                            html += `<img src="${img}" alt="post image" loading="lazy">`;
                        });
                        html += '</div>';
                    }

                    if (post.document) {
                        html += `<div class="post-document">[${post.document}]</div>`;
                    }

                    html += '</li>';
                    return html;
                }).join('');
            } catch (error) {
                container.innerHTML = '<li>Failed to load feed</li>';
                console.error('Error loading feed:', error);
            }
        }

        loadTelegramFeed();

        class Chicken {
            constructor(id) {
                this.element = document.createElement('div');
                this.element.className = 'chicken';
                this.element.id = 'chicken-' + id;
                document.body.appendChild(this.element);
                this.x = Math.random() * (window.innerWidth - 32);
                this.y = Math.random() * (window.innerHeight - 32);
                this.velocityX = (Math.random() - 0.5) * 2;
                this.velocityY = (Math.random() - 0.5) * 2;
                this.currentFrame = 0;
                this.frameTime = 0;
                this.animationSpeed = 200;
                this.currentAnimation = 'idle';
                this.isJumping = false;
                this.jumpTime = 0;
                this.isPecking = false;
                this.isIdling = false;
                this.idleTimer = 0;
                this.facingRight = true;
                this.jumpStartY = 0;
                this.jumpProgress = 0;
                this.targetFeed = null;
                this.followingMouse = false;
                this.normalVelocityX = this.velocityX;
                this.normalVelocityY = this.velocityY;

                this.animations = {
                    idle: { frames: [0, 1], speed: 500 },
                    walking: { frames: [2, 3, 4, 5], speed: 150 },
                    pecking: { frames: [6, 7], speed: 300 },
                    jumping: { frames: [8, 9], speed: 100 },
                    sitting: { frames: [10], speed: 1000 }
                };

                // Egg laying properties
                this.isLayingEgg = false;
                this.isSitting = false;
                this.sittingEgg = null;
                this.lastEggTime = 0;
                this.eggLayingCooldown = 30000; // 30 seconds between eggs
                this.isChick = false;

                this.updatePosition();
                this.setupEventListeners();
                this.animate();
            }

            updatePosition() {
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
            }

            updateSprite() {
                const frameX = this.currentFrame * 32;
                this.element.style.backgroundPosition = `-${frameX}px 0px`;
                this.element.style.transform = this.facingRight ? 'scaleX(-1)' : 'scaleX(1)';
            }

            setAnimation(animName) {
                if (this.currentAnimation !== animName) {
                    this.currentAnimation = animName;
                    this.currentFrame = this.animations[animName].frames[0];
                    this.frameTime = 0;
                }
            }

            updateAnimation(deltaTime) {
                // Don't update animation frames while sitting on egg - stay on sitting frame
                if (this.isSitting && this.currentAnimation === 'sitting') {
                    this.currentFrame = 10; // Force sitting frame
                    this.updateSprite();
                    return;
                }

                const anim = this.animations[this.currentAnimation];
                this.frameTime += deltaTime;

                if (this.frameTime >= anim.speed) {
                    this.frameTime = 0;
                    const currentFrameIndex = anim.frames.indexOf(this.currentFrame);
                    const nextFrameIndex = (currentFrameIndex + 1) % anim.frames.length;
                    this.currentFrame = anim.frames[nextFrameIndex];
                }

                this.updateSprite();
            }

            wander(deltaTime) {
                if (this.isJumping) {
                    this.updateJump(deltaTime);
                    return;
                }

                if (this.isPecking || this.isLayingEgg) return;

                // If sitting on egg, don't move at all
                if (this.isSitting) {
                    this.setAnimation('sitting');
                    return;
                }

                // Check for mouse following behavior
                if (feedSystem.hasMouseFood()) {
                    this.checkMouseProximity();
                }

                // Check for nearby eggs to sit on
                this.checkForEggsToSitOn();

                // Random egg laying
                if (!this.isChick && Math.random() < 0.0001 && (Date.now() - this.lastEggTime) > this.eggLayingCooldown) {
                    this.layEgg();
                    return;
                }

                // Handle feed targeting
                if (this.targetFeed) {
                    this.moveTowardFeed(deltaTime);
                    return;
                }

                // Handle mouse following
                if (this.followingMouse) {
                    this.followMouse();
                    return;
                }

                // Check for nearby feed if not already targeting one
                if (!this.targetFeed) {
                    this.checkForNearbyFeed();
                }

                // Handle idle timer first
                if (this.isIdling) {
                    this.idleTimer += deltaTime;
                    if (this.idleTimer >= this.idleDuration) {
                        this.isIdling = false;
                        this.idleTimer = 0;
                        // Start moving again with new random velocity
                        this.velocityX = (Math.random() - 0.5) * 2;
                        this.velocityY = (Math.random() - 0.5) * 2;
                        // Ensure they actually move by giving minimum velocity
                        if (Math.abs(this.velocityX) < 0.5) {
                            this.velocityX = this.velocityX >= 0 ? 0.5 : -0.5;
                        }
                        if (Math.abs(this.velocityY) < 0.5) {
                            this.velocityY = this.velocityY >= 0 ? 0.5 : -0.5;
                        }
                        // Don't return here - let them start moving immediately
                    } else {
                        return; // Only return if still idling
                    }
                }

                // Change direction occasionally
                if (Math.random() < 0.01) {
                    this.velocityX = (Math.random() - 0.5) * 2;
                    this.velocityY = (Math.random() - 0.5) * 2;
                }

                // Start pecking (stops movement)
                if (Math.random() < 0.005) {
                    this.isPecking = true;
                    this.setAnimation('pecking');
                    setTimeout(() => {
                        this.isPecking = false;
                        if (!this.isJumping && !this.isIdling) {
                            this.setAnimation(Math.abs(this.velocityX) + Math.abs(this.velocityY) > 0.1 ? 'walking' : 'idle');
                        }
                    }, 600);
                    return;
                }

                // Start idle (stops movement)
                if (Math.random() < 0.003) {
                    this.isIdling = true;
                    this.idleTimer = 0;
                    this.idleDuration = 1000 + Math.random() * 4000; // Random idle time 1-5 seconds
                    this.setAnimation('idle');
                    return;
                }

                this.x += this.velocityX;
                this.y += this.velocityY;

                // Update facing direction
                if (this.velocityX > 0.1) {
                    this.facingRight = true;
                } else if (this.velocityX < -0.1) {
                    this.facingRight = false;
                }

                // Boundary collision
                if (this.x <= 0 || this.x >= window.innerWidth - 32) {
                    this.velocityX = -this.velocityX;
                    this.x = Math.max(0, Math.min(window.innerWidth - 32, this.x));
                    this.facingRight = this.velocityX > 0;
                }
                if (this.y <= 0 || this.y >= window.innerHeight - 32) {
                    this.velocityY = -this.velocityY;
                    this.y = Math.max(0, Math.min(window.innerHeight - 32, this.y));
                }

                const isMoving = Math.abs(this.velocityX) + Math.abs(this.velocityY) > 0.1;
                this.setAnimation(isMoving ? 'walking' : 'idle');

                this.updatePosition();
            }

            updateJump(deltaTime) {
                this.jumpProgress += deltaTime / 800; // 800ms jump duration

                if (this.jumpProgress >= 1) {
                    this.isJumping = false;
                    this.jumpProgress = 0;
                    this.setAnimation(Math.abs(this.velocityX) + Math.abs(this.velocityY) > 0.1 ? 'walking' : 'idle');
                    return;
                }

                // Arc calculation: parabolic movement
                const jumpHeight = 60 * Math.sin(this.jumpProgress * Math.PI);
                const jumpDistance = 40 * this.jumpProgress;

                this.y = this.jumpStartY - jumpHeight;
                this.x += (this.facingRight ? jumpDistance : -jumpDistance) / 20; // Spread movement over time

                // Boundary check during jump
                this.x = Math.max(0, Math.min(window.innerWidth - 32, this.x));
                this.y = Math.max(0, Math.min(window.innerHeight - 32, this.y));

                this.updatePosition();
            }

            jump() {
                if (this.isJumping || this.isPecking) return;

                this.isJumping = true;
                this.isPecking = false;
                this.isIdling = false;
                this.jumpStartY = this.y;
                this.jumpProgress = 0;
                this.setAnimation('jumping');
            }

            checkMouseProximity() {
                const mousePos = feedSystem.getMousePosition();
                const distance = Math.sqrt(
                    Math.pow(this.x - mousePos.x, 2) +
                    Math.pow(this.y - mousePos.y, 2)
                );

                if (distance <= 100 && !this.followingMouse) {
                    this.followingMouse = true;
                    this.isIdling = false;
                } else if (distance > 150 && this.followingMouse) {
                    this.followingMouse = false;
                }
            }

            followMouse() {
                const mousePos = feedSystem.getMousePosition();
                const dx = mousePos.x - this.x;
                const dy = mousePos.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 20) {
                    this.velocityX = (dx / distance) * 1.5;
                    this.velocityY = (dy / distance) * 1.5;

                    // Update facing direction
                    this.facingRight = this.velocityX > 0;

                    this.x += this.velocityX;
                    this.y += this.velocityY;
                    this.setAnimation('walking');
                    this.updatePosition();
                }
            }

            rushToFeed(feed) {
                this.targetFeed = feed;
                this.followingMouse = false;
                this.isIdling = false;
                this.isPecking = false;
            }

            moveTowardFeed(deltaTime) {
                if (!this.targetFeed || !feedSystem.feeds.find(f => f.id === this.targetFeed.id)) {
                    this.targetFeed = null;
                    return;
                }

                const dx = this.targetFeed.x - this.x;
                const dy = this.targetFeed.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= 20) {
                    // At feed location, start pecking
                    this.peckAtFeed();
                } else {
                    // Move toward feed
                    this.velocityX = (dx / distance) * 2;
                    this.velocityY = (dy / distance) * 2;

                    // Update facing direction
                    this.facingRight = this.velocityX > 0;

                    this.x += this.velocityX;
                    this.y += this.velocityY;
                    this.setAnimation('walking');
                    this.updatePosition();
                }
            }

            checkForNearbyFeed() {
                let closestFeed = null;
                let closestDistance = Infinity;
                const radius = Math.min(window.innerWidth, window.innerHeight) / 4; // Smaller radius for continuous checking

                feedSystem.feeds.forEach(feed => {
                    const distance = Math.sqrt(
                        Math.pow(this.x - feed.x, 2) +
                        Math.pow(this.y - feed.y, 2)
                    );

                    if (distance <= radius && distance < closestDistance) {
                        closestDistance = distance;
                        closestFeed = feed;
                    }
                });

                if (closestFeed) {
                    this.rushToFeed(closestFeed);
                }
            }

            peckAtFeed() {
                if (!this.isPecking) {
                    this.isPecking = true;
                    this.setAnimation('pecking');

                    // Consume feed
                    const feedGone = feedSystem.consumeFeed(this.targetFeed.id);

                    setTimeout(() => {
                        this.isPecking = false;
                        if (feedGone || Math.random() < 0.3) {
                            // Feed is gone or chicken is satisfied
                            this.targetFeed = null;
                            this.velocityX = (Math.random() - 0.5) * 2;
                            this.velocityY = (Math.random() - 0.5) * 2;
                        }
                        this.setAnimation('idle');
                    }, 600);
                }
            }

            layEgg() {
                this.isLayingEgg = true;

                // Reset animation frame and time to ensure clean transition
                this.currentFrame = 10; // Force to sitting frame (frame 11, index 10)
                this.frameTime = 0;
                this.setAnimation('sitting');
                this.updateSprite(); // Immediately update sprite to sitting frame

                this.lastEggTime = Date.now();

                setTimeout(() => {
                    // Create egg at chicken's position
                    const egg = new Egg(this.x, this.y + 16, Date.now());
                    eggs.push(egg);

                    this.isLayingEgg = false;

                    // Reset to idle animation properly
                    this.currentFrame = 0;
                    this.frameTime = 0;
                    this.setAnimation('idle');

                    // Give the chicken new velocities to start moving again
                    this.velocityX = (Math.random() - 0.5) * 2;
                    this.velocityY = (Math.random() - 0.5) * 2;
                }, 1500); // Slightly longer for sitting pose
            }

            checkForEggsToSitOn() {
                if (this.isChick) return;

                const nearbyEgg = eggs.find(egg => {
                    const distance = Math.sqrt(
                        Math.pow(this.x - egg.x, 2) +
                        Math.pow(this.y - egg.y, 2)
                    );
                    // Only sit on eggs that are in 'waiting' state (not hatching or hatched)
                    return distance <= 30 &&
                           egg.state === 'waiting' &&
                           !egg.sittingChicken;
                });

                if (nearbyEgg && Math.random() < 0.01) {
                    this.startSittingOnEgg(nearbyEgg);
                }
            }

            startSittingOnEgg(egg) {
                // Double-check egg is still available for sitting
                if (egg.state !== 'waiting' || egg.sittingChicken) {
                    return; // Don't sit if egg is already hatching or has another chicken
                }

                this.isSitting = true;
                this.sittingEgg = egg;
                this.setAnimation('sitting');
                egg.startSitting(this);

                // Position chicken on egg
                this.x = egg.x;
                this.y = egg.y - 8;
                this.updatePosition();
            }

            stopSitting() {
                this.isSitting = false;
                this.sittingEgg = null;

                // Reset animation frame and force back to normal behavior
                this.currentFrame = 0;
                this.frameTime = 0;
                this.setAnimation('idle');

                // Move chicken slightly away from egg
                this.x += (Math.random() - 0.5) * 30;
                this.y += (Math.random() - 0.5) * 30;

                // Ensure position stays within bounds
                this.x = Math.max(0, Math.min(window.innerWidth - 32, this.x));
                this.y = Math.max(0, Math.min(window.innerHeight - 32, this.y));
                this.updatePosition();

                // Reset velocities to ensure they start moving again
                this.velocityX = (Math.random() - 0.5) * 2;
                this.velocityY = (Math.random() - 0.5) * 2;

                // Force a small movement to break any potential stuck state
                setTimeout(() => {
                    if (!this.isSitting && !this.isLayingEgg && !this.isPecking) {
                        this.x += this.velocityX * 5;
                        this.y += this.velocityY * 5;
                        this.updatePosition();
                    }
                }, 100);
            }

            updateSitting(deltaTime) {
                if (this.isSitting && this.sittingEgg) {
                    const shouldStop = this.sittingEgg.updateSitting(deltaTime);
                    if (shouldStop) {
                        this.stopSitting();
                    }
                    return shouldStop;
                }
                return false;
            }

            setupEventListeners() {
                this.element.addEventListener('mouseenter', () => {
                    this.jump();
                });

                window.addEventListener('resize', () => {
                    this.x = Math.min(this.x, window.innerWidth - 32);
                    this.y = Math.min(this.y, window.innerHeight - 32);
                    this.updatePosition();
                });
            }

            animate() {
                let lastTime = 0;

                const gameLoop = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;

                    this.updateAnimation(deltaTime);
                    this.updateSitting(deltaTime);
                    this.wander(deltaTime);

                    requestAnimationFrame(gameLoop);
                };

                requestAnimationFrame(gameLoop);
            }
        }

        // Chick class - similar to Chicken but smaller and runs from mouse
        class Chick extends Chicken {
            constructor(id, parentChicken = null) {
                super(id);

                // Override element creation for chick
                this.element.remove(); // Remove the chicken element
                this.element = document.createElement('div');
                this.element.className = 'chick';
                this.element.id = 'chick-' + id;
                document.body.appendChild(this.element);

                // Chick-specific properties
                this.isRunningAway = false;
                this.runAwayTimer = 0;
                this.originalSpeed = 1;
                this.runAwaySpeed = 4;
                this.parentChicken = parentChicken;
                this.isChick = true;
                this.followingParent = false;
                this.isRiding = false;

                // Override animations for chick sprite sheet
                this.animations = {
                    idle: { frames: [0, 1], speed: 500 },
                    walking: { frames: [2, 3], speed: 150 },
                    pecking: { frames: [4, 5], speed: 300 },
                    running: { frames: [2, 3], speed: 100 }, // Fast walk animation for running
                    riding: { frames: [1], speed: 1000 } // Frame 2 (index 1) for riding
                };

                this.updatePosition();
                this.setupChickEventListeners();
            }

            updateSprite() {
                const frameX = this.currentFrame * 16; // 16px per frame for chick
                this.element.style.backgroundPosition = `-${frameX}px 0px`;
                this.element.style.transform = this.facingRight ? 'scaleX(-1)' : 'scaleX(1)';
            }

            setupChickEventListeners() {
                this.element.addEventListener('mouseenter', () => {
                    if (this.isRiding) {
                        this.stopRiding();
                    } else {
                        this.runAway();
                    }
                });

                // Also listen for mouseover on parent chicken when riding
                if (this.parentChicken && this.parentChicken.element) {
                    this.parentChicken.element.addEventListener('mouseenter', () => {
                        if (this.isRiding) {
                            this.stopRiding();
                        }
                    });
                }

                window.addEventListener('resize', () => {
                    this.x = Math.min(this.x, window.innerWidth - 16);
                    this.y = Math.min(this.y, window.innerHeight - 16);
                    this.updatePosition();
                });

                // Track mouse position for running away
                document.addEventListener('mousemove', (e) => {
                    if (this.isRunningAway) {
                        this.checkMouseDistance(e.clientX, e.clientY);
                    }
                });
            }

            runAway() {
                if (!this.isRunningAway) {
                    this.isRunningAway = true;
                    this.runAwayTimer = 0;
                    this.isPecking = false;
                    this.isIdling = false;
                    this.targetFeed = null;
                    this.followingMouse = false;
                }
            }

            checkMouseDistance(mouseX, mouseY) {
                const distance = Math.sqrt(
                    Math.pow(this.x - mouseX, 2) +
                    Math.pow(this.y - mouseY, 2)
                );

                if (distance > 100) { // Stop running when far enough
                    this.isRunningAway = false;
                    this.runAwayTimer = 0;
                }
            }

            wander(deltaTime) {
                if (this.isJumping) {
                    this.updateJump(deltaTime);
                    return;
                }

                if (this.isPecking) return;

                // Handle running away behavior
                if (this.isRunningAway) {
                    this.runAwayTimer += deltaTime;
                    this.runAwayFromMouse();

                    // Stop running after 3 seconds max
                    if (this.runAwayTimer >= 3000) {
                        this.isRunningAway = false;
                        this.runAwayTimer = 0;
                    }
                    return;
                }

                // Check if parent is still alive and follow them
                if (this.parentChicken && chickens.includes(this.parentChicken) && !this.parentChicken.isChick) {
                    // Ensure parent reference is valid
                    if (!this.parentChicken.element || !this.parentChicken.element.parentNode) {
                        this.parentChicken = null;
                        return;
                    }

                    // Don't interfere with parent if they're sitting on an egg
                    if (this.parentChicken.isSitting) {
                        // Stay nearby but don't follow actively to avoid disrupting sitting behavior
                        const distance = Math.sqrt(
                            Math.pow(this.parentChicken.x - this.x, 2) +
                            Math.pow(this.parentChicken.y - this.y, 2)
                        );

                        if (distance > 60) {
                            // Move toward sitting parent but stop before getting too close
                            const dx = this.parentChicken.x - this.x;
                            const dy = this.parentChicken.y - this.y;
                            const targetDistance = 50; // Stop at comfortable distance

                            if (distance > targetDistance) {
                                this.velocityX = (dx / distance) * 1.0;
                                this.velocityY = (dy / distance) * 1.0;
                                this.x += this.velocityX;
                                this.y += this.velocityY;
                                this.facingRight = this.velocityX > 0;
                                this.setAnimation('walking');
                                this.updatePosition();
                                return;
                            }
                        }

                        // Close enough to sitting parent - just idle nearby
                        this.setAnimation('idle');
                        return;
                    }

                    const distance = Math.sqrt(
                        Math.pow(this.parentChicken.x - this.x, 2) +
                        Math.pow(this.parentChicken.y - this.y, 2)
                    );

                    // Check if should start riding (less frequent)
                    if (!this.isRiding && distance <= 15 && Math.random() < 0.003) {
                        this.startRiding();
                        return;
                    }

                    // If riding, stay on parent's back
                    if (this.isRiding) {
                        this.rideParent();
                        return;
                    }

                    // Follow if too far from parent
                    if (distance > 80) { // Even more wandering room
                        this.followParent();
                        return;
                    }

                    // If moderately close to parent, allow some wandering
                    if (distance > 45) {
                        if (Math.random() < 0.1) { // 10% chance to follow, 90% to wander
                            this.followParent();
                            return;
                        }
                    }

                    // Close to parent - continue with normal wandering behavior
                    // This allows chicks to explore around their parent
                }

                // Use parent wander logic for normal behavior
                super.wander(deltaTime);
            }

            runAwayFromMouse() {
                const mousePos = feedSystem.getMousePosition();
                const dx = this.x - mousePos.x;
                const dy = this.y - mousePos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    // Run in opposite direction from mouse
                    this.velocityX = (dx / distance) * this.runAwaySpeed;
                    this.velocityY = (dy / distance) * this.runAwaySpeed;

                    // Update facing direction
                    this.facingRight = this.velocityX > 0;

                    this.x += this.velocityX;
                    this.y += this.velocityY;

                    // Boundary collision
                    if (this.x <= 0 || this.x >= window.innerWidth - 16) {
                        this.velocityX = -this.velocityX;
                        this.x = Math.max(0, Math.min(window.innerWidth - 16, this.x));
                    }
                    if (this.y <= 0 || this.y >= window.innerHeight - 16) {
                        this.velocityY = -this.velocityY;
                        this.y = Math.max(0, Math.min(window.innerHeight - 16, this.y));
                    }

                    this.setAnimation('running');
                    this.updatePosition();
                }
            }

            followParent() {
                if (!this.parentChicken) return;

                const dx = this.parentChicken.x - this.x;
                const dy = this.parentChicken.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 40) { // More following distance
                    this.velocityX = (dx / distance) * 1.8;
                    this.velocityY = (dy / distance) * 1.8;

                    // Update facing direction
                    this.facingRight = this.velocityX > 0;

                    this.x += this.velocityX;
                    this.y += this.velocityY;

                    // Boundary collision
                    if (this.x <= 0 || this.x >= window.innerWidth - 16) {
                        this.velocityX = -this.velocityX;
                        this.x = Math.max(0, Math.min(window.innerWidth - 16, this.x));
                    }
                    if (this.y <= 0 || this.y >= window.innerHeight - 16) {
                        this.velocityY = -this.velocityY;
                        this.y = Math.max(0, Math.min(window.innerHeight - 16, this.y));
                    }

                    this.setAnimation('walking');
                    this.updatePosition();
                } else {
                    // Close enough to parent, just idle
                    this.setAnimation('idle');
                }
            }

            startRiding() {
                this.isRiding = true;
                this.setAnimation('riding');
                // Random chance to stop riding after shorter time
                setTimeout(() => {
                    if (this.isRiding && Math.random() < 0.8) {
                        this.stopRiding();
                    }
                }, 1500 + Math.random() * 2000); // 1.5-3.5 seconds
            }

            stopRiding() {
                this.isRiding = false;
                // Move slightly off the parent's back
                this.x += (Math.random() - 0.5) * 20;
                this.y += (Math.random() - 0.5) * 20;
                this.updatePosition();
                this.setAnimation('idle');
            }

            rideParent() {
                if (!this.parentChicken) {
                    this.stopRiding();
                    return;
                }

                // Position chick on parent's back (more centered and lower)
                this.x = this.parentChicken.x + 2; // Slightly toward center
                this.y = this.parentChicken.y - 8; // Lower on the back

                // Face same direction as parent
                this.facingRight = this.parentChicken.facingRight;

                this.updatePosition();
                this.setAnimation('riding');

                // Small chance to get off while riding
                if (Math.random() < 0.002) {
                    this.stopRiding();
                }
            }
        }

        // Egg class for hatching system
        class Egg {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.element = document.createElement('div');
                this.element.className = 'egg';
                this.element.id = 'egg-' + id;
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                document.body.appendChild(this.element);

                this.currentFrame = 0;
                this.frameTime = 0;
                this.state = 'waiting'; // waiting, hatching, hatched
                this.sittingChicken = null;
                this.sittingTime = 0;
                this.sittingRequired = 10000; // 10 seconds

                this.updateSprite();
            }

            updateSprite() {
                const frameX = this.currentFrame * 16;
                this.element.style.backgroundPosition = `-${frameX}px 0px`;
            }

            startSitting(chicken) {
                if (this.state === 'waiting' && !this.sittingChicken) {
                    this.sittingChicken = chicken;
                    this.parentChickenRef = chicken; // Store reference for later
                    this.sittingTime = 0;
                }
            }

            updateSitting(deltaTime) {
                if (this.sittingChicken && this.state === 'waiting') {
                    this.sittingTime += deltaTime;

                    if (this.sittingTime >= this.sittingRequired) {
                        // Immediately free the chicken before starting hatching
                        const parentChicken = this.sittingChicken;
                        this.sittingChicken = null;

                        if (parentChicken) {
                            parentChicken.stopSitting();
                        }

                        // Wait 2 seconds for chicken to move away before hatching
                        setTimeout(() => {
                            this.startHatching();
                        }, 2000);

                        return true; // Chicken can leave
                    }
                }
                return false;
            }

            startHatching() {
                this.state = 'hatching';
                this.currentFrame = 1;
                this.frameTime = 0;
                // sittingChicken should already be null from updateSitting()

                this.animateHatching();
            }

            animateHatching() {
                const hatchingFrames = [1, 2, 3, 4]; // hatching, chick peeking, chick popping, empty shell
                let frameIndex = 0;

                const animate = () => {
                    if (frameIndex < hatchingFrames.length - 1) {
                        this.currentFrame = hatchingFrames[frameIndex];
                        this.updateSprite();
                        frameIndex++;
                        setTimeout(animate, 800); // 800ms per frame
                    } else if (frameIndex === hatchingFrames.length - 1) {
                        // Create chick before showing empty shell
                        this.hatch();
                        // Show empty shell
                        this.currentFrame = hatchingFrames[frameIndex];
                        this.updateSprite();
                        // Remove shell after 2 seconds
                        setTimeout(() => {
                            this.element.remove();
                            eggs = eggs.filter(e => e.id !== this.id);
                        }, 2000);
                    }
                };

                animate();
            }

            hatch() {
                this.state = 'hatched';

                // Use stored parent reference first, then fallback to nearby search
                let parentChicken = this.parentChickenRef;
                if (!parentChicken || !chickens.includes(parentChicken)) {
                    parentChicken = this.findParentChicken();
                }

                const chick = new Chick(Date.now(), parentChicken);
                chick.x = this.x + (Math.random() - 0.5) * 10; // Slight random offset
                chick.y = this.y + (Math.random() - 0.5) * 10;

                // Ensure chick has initial velocities
                chick.velocityX = (Math.random() - 0.5) * 1.5;
                chick.velocityY = (Math.random() - 0.5) * 1.5;

                chick.updatePosition();

                // Add to chickens array
                chickens.push(chick);

                // Don't remove egg here - it will be removed after showing empty shell
            }

            findParentChicken() {
                // Find the chicken that was sitting on this egg
                // Look for adult chickens near the egg location
                return chickens.find(chicken =>
                    chicken instanceof Chicken &&
                    !chicken.isChick &&
                    chicken.constructor.name === 'Chicken' && // Make sure it's not a Chick instance
                    Math.sqrt(Math.pow(chicken.x - this.x, 2) + Math.pow(chicken.y - this.y, 2)) < 80
                );
            }

            remove() {
                this.element.remove();
            }
        }

        // Feed system
        class FeedSystem {
            constructor() {
                this.hasFood = false;
                this.feeds = [];
                this.mouseFeed = document.getElementById('mouse-feed');
                this.feedBag = document.getElementById('feed-bag');
                this.mouseX = 0;
                this.mouseY = 0;

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Feed bag click
                this.feedBag.addEventListener('click', () => {
                    this.hasFood = true;
                    this.mouseFeed.style.display = 'block';
                    document.body.style.cursor = 'none';
                });

                // Mouse movement tracking
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    if (this.hasFood) {
                        this.mouseFeed.style.left = (e.clientX - 8) + 'px';
                        this.mouseFeed.style.top = (e.clientY - 8) + 'px';
                    }
                });

                // Screen click to place feed
                document.addEventListener('click', (e) => {
                    if (this.hasFood && !e.target.closest('#feed-bag') && !e.target.closest('.links-section')) {
                        this.placeFeed(e.clientX, e.clientY);
                        this.hasFood = false;
                        this.mouseFeed.style.display = 'none';
                        document.body.style.cursor = 'default';
                    }
                });
            }

            placeFeed(x, y) {
                const feed = {
                    x: x - 8,
                    y: y - 8,
                    element: document.createElement('div'),
                    amount: 100,
                    maxAmount: 100,
                    id: Date.now()
                };

                feed.element.className = 'feed';
                feed.element.style.left = feed.x + 'px';
                feed.element.style.top = feed.y + 'px';
                this.updateFeedSprite(feed);
                document.body.appendChild(feed.element);
                this.feeds.push(feed);

                // Notify nearby chickens
                this.notifyChickens(feed);
            }

            updateFeedSprite(feed) {
                const percentage = feed.amount / feed.maxAmount;
                let frameX = 0;

                if (percentage > 0.66) {
                    frameX = 0; // Full feed (sprite 1)
                } else if (percentage > 0.33) {
                    frameX = -16; // Half gone (sprite 2)
                } else if (percentage > 0) {
                    frameX = -32; // Almost gone (sprite 3)
                }

                feed.element.style.backgroundPosition = `${frameX}px 0px`;
            }

            notifyChickens(feed) {
                const radius = Math.min(window.innerWidth, window.innerHeight) / 2;
                chickens.forEach(chicken => {
                    const distance = Math.sqrt(
                        Math.pow(chicken.x - feed.x, 2) +
                        Math.pow(chicken.y - feed.y, 2)
                    );
                    if (distance <= radius) {
                        chicken.rushToFeed(feed);
                    }
                });
            }

            consumeFeed(feedId, amount = 10) {
                const feed = this.feeds.find(f => f.id === feedId);
                if (feed) {
                    feed.amount -= amount;
                    this.updateFeedSprite(feed);

                    if (feed.amount <= 0) {
                        feed.element.remove();
                        this.feeds = this.feeds.filter(f => f.id !== feedId);
                        return true; // Feed is gone
                    }
                }
                return false;
            }

            getMousePosition() {
                return { x: this.mouseX, y: this.mouseY };
            }

            hasMouseFood() {
                return this.hasFood;
            }
        }

        // Create feed system
        const feedSystem = new FeedSystem();

        // Create arrays for chickens and eggs
        const chickens = [];
        const eggs = [];

        // Create 20 chickens
        for (let i = 0; i < 20; i++) {
            chickens.push(new Chicken(i));
        }

    </script>
</body>
</html>
