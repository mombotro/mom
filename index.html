<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>need more chickens</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #ffffff;
            font-family: monospace;
            font-size: 14px;
        }

        .links-section {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 1px solid #ccc;
        }

        .links-section h2 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        .links-section ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .links-section li {
            margin: 5px 0;
        }

        .links-section a {
            color: #0000EE;
            text-decoration: underline;
        }

        .links-section a:visited {
            color: #551A8B;
        }

        .chicken {
            position: absolute;
            width: 32px;
            height: 32px;
            background-image: url('./assets/chicken.PNG');
            background-repeat: no-repeat;
            image-rendering: pixelated;
            z-index: 999;
        }

        #feed-bag {
            position: fixed;
            top: 50%;
            right: 20px;
            width: 64px;
            height: 64px;
            background-image: url('./assets/feed-bag.PNG');
            background-size: contain;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            cursor: pointer;
            z-index: 1001;
            transform: translateY(-50%);
        }

        #feed-bag:hover {
            filter: brightness(1.2);
        }

        .feed {
            position: absolute;
            width: 16px;
            height: 16px;
            background-image: url('./assets/feed.PNG');
            background-repeat: no-repeat;
            background-position: 0px 0px;
            image-rendering: pixelated;
            z-index: 998;
        }

        .mouse-feed {
            position: fixed;
            width: 16px;
            height: 16px;
            background-image: url('./assets/feed.PNG');
            background-repeat: no-repeat;
            background-position: 0px 0px;
            image-rendering: pixelated;
            z-index: 1002;
            pointer-events: none;
            display: none;
        }

        .farm-building {
            position: absolute;
            border: 2px dashed #8B4513;
            background: rgba(139, 69, 19, 0.1);
            padding: 15px;
            box-sizing: border-box;
            font-family: monospace;
            z-index: 500;
            text-decoration: none;
            display: block;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .farm-building:hover {
            background: rgba(139, 69, 19, 0.2);
            border-color: #654321;
            transform: scale(1.05);
        }

        .farm-building h3 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #8B4513;
            font-weight: bold;
        }

        .farm-building p {
            margin: 0;
            font-size: 12px;
            color: #666;
            font-style: italic;
        }

        .farm-building.coming-soon {
            opacity: 0.6;
            cursor: default;
        }

        .farm-building.coming-soon:hover {
            transform: none;
            background: rgba(139, 69, 19, 0.1);
        }

        /* Individual building positions */
        #farmhouse {
            top: 50px;
            left: 50%;
            margin-left: -90px;
            width: 180px;
            height: 120px;
        }

        #chicken-coop {
            top: 250px;
            left: 280px;
            width: 150px;
            height: 100px;
        }

        #workshop {
            top: 200px;
            right: 100px;
            width: 160px;
            height: 100px;
        }

        #garden {
            bottom: 100px;
            left: 100px;
            width: 170px;
            height: 120px;
        }

        #farm-stand {
            bottom: 100px;
            right: 100px;
            width: 150px;
            height: 100px;
        }
    </style>
</head>
<body>
    <div class="links-section">
        <h2>mom's stuff</h2>
        <ul>
            <li><a href="https://t.me/mombotpro">mombot telegram feed</a></li>
            <li><a href="https://www.webtoons.com/en/canvas/liminal-b/list?title_no=443514">Liminal webtoon -complete-</a></li>
            <li><a href="https://mombot.nekoweb.org/mosaic">mosaic</a></li>
            <li><a href="https://mombotro.itch.io/">itch.io</a></li>
            <li><a href="https://ko-fi.com/azirona">ko-fi</a></li>
        </ul>
        <h2>cool links</h2>
        <ul>
            <li><a href="https://archive.org/details/babettes-feast">good movie</a></li>
            <li><a href="https://www.cherokeedictionary.net/grammar">Cherokee dictionary</a></li>
            <li><a href="https://drawingbooks.org/">open drawing books</a></li>
        </ul>
    </div>

    <div id="feed-bag" title="Click to get chicken feed"></div>
    <div id="mouse-feed" class="mouse-feed"></div>

    <!-- Farm Buildings -->
    <div id="farmhouse" class="farm-building coming-soon">
        <h3>üè† FARMHOUSE</h3>
        <p>About/Contact</p>
        <p style="margin-top: 10px; font-size: 10px;">(coming soon)</p>
    </div>

    <a id="chicken-coop" class="farm-building" href="./gallery/comics/">
        <h3>üêî CHICKEN COOP</h3>
        <p>Comics/Webcomics</p>
    </a>

    <a id="workshop" class="farm-building" href="./gallery/tools/">
        <h3>üî® WORKSHOP</h3>
        <p>Little Programs & Tools</p>
    </a>

    <a id="garden" class="farm-building" href="./gallery/projects/">
        <h3>üå± GARDEN</h3>
        <p>3D Printing & Embroidery</p>
    </a>

    <div id="farm-stand" class="farm-building coming-soon">
        <h3>üõí FARM STAND</h3>
        <p>Stores & Links</p>
        <p style="margin-top: 10px; font-size: 10px;">(coming soon)</p>
    </div>

    <!-- Chickens will be created dynamically -->

    <script>
        class Chicken {
            constructor(id) {
                this.element = document.createElement('div');
                this.element.className = 'chicken';
                this.element.id = 'chicken-' + id;
                document.body.appendChild(this.element);
                this.x = Math.random() * (window.innerWidth - 32);
                this.y = Math.random() * (window.innerHeight - 32);
                this.velocityX = (Math.random() - 0.5) * 2;
                this.velocityY = (Math.random() - 0.5) * 2;
                this.currentFrame = 0;
                this.frameTime = 0;
                this.animationSpeed = 200;
                this.currentAnimation = 'idle';
                this.isJumping = false;
                this.jumpTime = 0;
                this.isPecking = false;
                this.isIdling = false;
                this.idleTimer = 0;
                this.facingRight = true;
                this.jumpStartY = 0;
                this.jumpProgress = 0;
                this.targetFeed = null;
                this.followingMouse = false;
                this.normalVelocityX = this.velocityX;
                this.normalVelocityY = this.velocityY;

                this.animations = {
                    idle: { frames: [0, 1], speed: 500 },
                    walking: { frames: [2, 3, 4, 5], speed: 150 },
                    pecking: { frames: [6, 7], speed: 300 },
                    jumping: { frames: [8, 9], speed: 100 }
                };

                this.updatePosition();
                this.setupEventListeners();
                this.animate();
            }

            updatePosition() {
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
            }

            updateSprite() {
                const frameX = this.currentFrame * 32;
                this.element.style.backgroundPosition = `-${frameX}px 0px`;
                this.element.style.transform = this.facingRight ? 'scaleX(-1)' : 'scaleX(1)';
            }

            setAnimation(animName) {
                if (this.currentAnimation !== animName) {
                    this.currentAnimation = animName;
                    this.currentFrame = this.animations[animName].frames[0];
                    this.frameTime = 0;
                }
            }

            updateAnimation(deltaTime) {
                const anim = this.animations[this.currentAnimation];
                this.frameTime += deltaTime;

                if (this.frameTime >= anim.speed) {
                    this.frameTime = 0;
                    const currentFrameIndex = anim.frames.indexOf(this.currentFrame);
                    const nextFrameIndex = (currentFrameIndex + 1) % anim.frames.length;
                    this.currentFrame = anim.frames[nextFrameIndex];
                }

                this.updateSprite();
            }

            wander(deltaTime) {
                if (this.isJumping) {
                    this.updateJump(deltaTime);
                    return;
                }

                if (this.isPecking) return;

                // Check for mouse following behavior
                if (feedSystem.hasMouseFood()) {
                    this.checkMouseProximity();
                }

                // Handle feed targeting
                if (this.targetFeed) {
                    this.moveTowardFeed(deltaTime);
                    return;
                }

                // Handle mouse following
                if (this.followingMouse) {
                    this.followMouse();
                    return;
                }

                // Check for nearby feed if not already targeting one
                if (!this.targetFeed) {
                    this.checkForNearbyFeed();
                }

                // Handle idle timer first
                if (this.isIdling) {
                    this.idleTimer += deltaTime;
                    if (this.idleTimer >= this.idleDuration) {
                        this.isIdling = false;
                        this.idleTimer = 0;
                        // Start moving again with new random velocity
                        this.velocityX = (Math.random() - 0.5) * 2;
                        this.velocityY = (Math.random() - 0.5) * 2;
                        // Ensure they actually move by giving minimum velocity
                        if (Math.abs(this.velocityX) < 0.5) {
                            this.velocityX = this.velocityX >= 0 ? 0.5 : -0.5;
                        }
                        if (Math.abs(this.velocityY) < 0.5) {
                            this.velocityY = this.velocityY >= 0 ? 0.5 : -0.5;
                        }
                        // Don't return here - let them start moving immediately
                    } else {
                        return; // Only return if still idling
                    }
                }

                // Change direction occasionally
                if (Math.random() < 0.01) {
                    this.velocityX = (Math.random() - 0.5) * 2;
                    this.velocityY = (Math.random() - 0.5) * 2;
                }

                // Start pecking (stops movement)
                if (Math.random() < 0.005) {
                    this.isPecking = true;
                    this.setAnimation('pecking');
                    setTimeout(() => {
                        this.isPecking = false;
                        if (!this.isJumping && !this.isIdling) {
                            this.setAnimation(Math.abs(this.velocityX) + Math.abs(this.velocityY) > 0.1 ? 'walking' : 'idle');
                        }
                    }, 600);
                    return;
                }

                // Start idle (stops movement)
                if (Math.random() < 0.003) {
                    this.isIdling = true;
                    this.idleTimer = 0;
                    this.idleDuration = 1000 + Math.random() * 4000; // Random idle time 1-5 seconds
                    this.setAnimation('idle');
                    return;
                }

                this.x += this.velocityX;
                this.y += this.velocityY;

                // Update facing direction
                if (this.velocityX > 0.1) {
                    this.facingRight = true;
                } else if (this.velocityX < -0.1) {
                    this.facingRight = false;
                }

                // Boundary collision
                if (this.x <= 0 || this.x >= window.innerWidth - 32) {
                    this.velocityX = -this.velocityX;
                    this.x = Math.max(0, Math.min(window.innerWidth - 32, this.x));
                    this.facingRight = this.velocityX > 0;
                }
                if (this.y <= 0 || this.y >= window.innerHeight - 32) {
                    this.velocityY = -this.velocityY;
                    this.y = Math.max(0, Math.min(window.innerHeight - 32, this.y));
                }

                const isMoving = Math.abs(this.velocityX) + Math.abs(this.velocityY) > 0.1;
                this.setAnimation(isMoving ? 'walking' : 'idle');

                this.updatePosition();
            }

            updateJump(deltaTime) {
                this.jumpProgress += deltaTime / 800; // 800ms jump duration

                if (this.jumpProgress >= 1) {
                    this.isJumping = false;
                    this.jumpProgress = 0;
                    this.setAnimation(Math.abs(this.velocityX) + Math.abs(this.velocityY) > 0.1 ? 'walking' : 'idle');
                    return;
                }

                // Arc calculation: parabolic movement
                const jumpHeight = 60 * Math.sin(this.jumpProgress * Math.PI);
                const jumpDistance = 40 * this.jumpProgress;

                this.y = this.jumpStartY - jumpHeight;
                this.x += (this.facingRight ? jumpDistance : -jumpDistance) / 20; // Spread movement over time

                // Boundary check during jump
                this.x = Math.max(0, Math.min(window.innerWidth - 32, this.x));
                this.y = Math.max(0, Math.min(window.innerHeight - 32, this.y));

                this.updatePosition();
            }

            jump() {
                if (this.isJumping || this.isPecking) return;

                this.isJumping = true;
                this.isPecking = false;
                this.isIdling = false;
                this.jumpStartY = this.y;
                this.jumpProgress = 0;
                this.setAnimation('jumping');
            }

            checkMouseProximity() {
                const mousePos = feedSystem.getMousePosition();
                const distance = Math.sqrt(
                    Math.pow(this.x - mousePos.x, 2) +
                    Math.pow(this.y - mousePos.y, 2)
                );

                if (distance <= 100 && !this.followingMouse) {
                    this.followingMouse = true;
                    this.isIdling = false;
                } else if (distance > 150 && this.followingMouse) {
                    this.followingMouse = false;
                }
            }

            followMouse() {
                const mousePos = feedSystem.getMousePosition();
                const dx = mousePos.x - this.x;
                const dy = mousePos.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 20) {
                    this.velocityX = (dx / distance) * 1.5;
                    this.velocityY = (dy / distance) * 1.5;

                    // Update facing direction
                    this.facingRight = this.velocityX > 0;

                    this.x += this.velocityX;
                    this.y += this.velocityY;
                    this.setAnimation('walking');
                    this.updatePosition();
                }
            }

            rushToFeed(feed) {
                this.targetFeed = feed;
                this.followingMouse = false;
                this.isIdling = false;
                this.isPecking = false;
            }

            moveTowardFeed(deltaTime) {
                if (!this.targetFeed || !feedSystem.feeds.find(f => f.id === this.targetFeed.id)) {
                    this.targetFeed = null;
                    return;
                }

                const dx = this.targetFeed.x - this.x;
                const dy = this.targetFeed.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= 20) {
                    // At feed location, start pecking
                    this.peckAtFeed();
                } else {
                    // Move toward feed
                    this.velocityX = (dx / distance) * 2;
                    this.velocityY = (dy / distance) * 2;

                    // Update facing direction
                    this.facingRight = this.velocityX > 0;

                    this.x += this.velocityX;
                    this.y += this.velocityY;
                    this.setAnimation('walking');
                    this.updatePosition();
                }
            }

            checkForNearbyFeed() {
                let closestFeed = null;
                let closestDistance = Infinity;
                const radius = Math.min(window.innerWidth, window.innerHeight) / 4; // Smaller radius for continuous checking

                feedSystem.feeds.forEach(feed => {
                    const distance = Math.sqrt(
                        Math.pow(this.x - feed.x, 2) +
                        Math.pow(this.y - feed.y, 2)
                    );

                    if (distance <= radius && distance < closestDistance) {
                        closestDistance = distance;
                        closestFeed = feed;
                    }
                });

                if (closestFeed) {
                    this.rushToFeed(closestFeed);
                }
            }

            peckAtFeed() {
                if (!this.isPecking) {
                    this.isPecking = true;
                    this.setAnimation('pecking');

                    // Consume feed
                    const feedGone = feedSystem.consumeFeed(this.targetFeed.id);

                    setTimeout(() => {
                        this.isPecking = false;
                        if (feedGone || Math.random() < 0.3) {
                            // Feed is gone or chicken is satisfied
                            this.targetFeed = null;
                            this.velocityX = (Math.random() - 0.5) * 2;
                            this.velocityY = (Math.random() - 0.5) * 2;
                        }
                        this.setAnimation('idle');
                    }, 600);
                }
            }

            setupEventListeners() {
                this.element.addEventListener('mouseenter', () => {
                    this.jump();
                });

                window.addEventListener('resize', () => {
                    this.x = Math.min(this.x, window.innerWidth - 32);
                    this.y = Math.min(this.y, window.innerHeight - 32);
                    this.updatePosition();
                });
            }

            animate() {
                let lastTime = 0;

                const gameLoop = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;

                    this.updateAnimation(deltaTime);
                    this.wander(deltaTime);

                    requestAnimationFrame(gameLoop);
                };

                requestAnimationFrame(gameLoop);
            }
        }

        // Feed system
        class FeedSystem {
            constructor() {
                this.hasFood = false;
                this.feeds = [];
                this.mouseFeed = document.getElementById('mouse-feed');
                this.feedBag = document.getElementById('feed-bag');
                this.mouseX = 0;
                this.mouseY = 0;

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Feed bag click
                this.feedBag.addEventListener('click', () => {
                    this.hasFood = true;
                    this.mouseFeed.style.display = 'block';
                    document.body.style.cursor = 'none';
                });

                // Mouse movement tracking
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    if (this.hasFood) {
                        this.mouseFeed.style.left = (e.clientX - 8) + 'px';
                        this.mouseFeed.style.top = (e.clientY - 8) + 'px';
                    }
                });

                // Screen click to place feed
                document.addEventListener('click', (e) => {
                    if (this.hasFood && !e.target.closest('#feed-bag') && !e.target.closest('.links-section')) {
                        this.placeFeed(e.clientX, e.clientY);
                        this.hasFood = false;
                        this.mouseFeed.style.display = 'none';
                        document.body.style.cursor = 'default';
                    }
                });
            }

            placeFeed(x, y) {
                const feed = {
                    x: x - 8,
                    y: y - 8,
                    element: document.createElement('div'),
                    amount: 100,
                    maxAmount: 100,
                    id: Date.now()
                };

                feed.element.className = 'feed';
                feed.element.style.left = feed.x + 'px';
                feed.element.style.top = feed.y + 'px';
                this.updateFeedSprite(feed);
                document.body.appendChild(feed.element);
                this.feeds.push(feed);

                // Notify nearby chickens
                this.notifyChickens(feed);
            }

            updateFeedSprite(feed) {
                const percentage = feed.amount / feed.maxAmount;
                let frameX = 0;

                if (percentage > 0.66) {
                    frameX = 0; // Full feed (sprite 1)
                } else if (percentage > 0.33) {
                    frameX = -16; // Half gone (sprite 2)
                } else if (percentage > 0) {
                    frameX = -32; // Almost gone (sprite 3)
                }

                feed.element.style.backgroundPosition = `${frameX}px 0px`;
            }

            notifyChickens(feed) {
                const radius = Math.min(window.innerWidth, window.innerHeight) / 2;
                chickens.forEach(chicken => {
                    const distance = Math.sqrt(
                        Math.pow(chicken.x - feed.x, 2) +
                        Math.pow(chicken.y - feed.y, 2)
                    );
                    if (distance <= radius) {
                        chicken.rushToFeed(feed);
                    }
                });
            }

            consumeFeed(feedId, amount = 10) {
                const feed = this.feeds.find(f => f.id === feedId);
                if (feed) {
                    feed.amount -= amount;
                    this.updateFeedSprite(feed);

                    if (feed.amount <= 0) {
                        feed.element.remove();
                        this.feeds = this.feeds.filter(f => f.id !== feedId);
                        return true; // Feed is gone
                    }
                }
                return false;
            }

            getMousePosition() {
                return { x: this.mouseX, y: this.mouseY };
            }

            hasMouseFood() {
                return this.hasFood;
            }
        }

        // Create feed system
        const feedSystem = new FeedSystem();

        // Create 20 chickens
        const chickens = [];
        for (let i = 0; i < 20; i++) {
            chickens.push(new Chicken(i));
        }
    </script>
</body>
</html>
